#!/usr/bin/env python3
"""
Juniper SRX Vulnerability Monitoring System
IT Security Specialist - ISP/NOC

This script provides comprehensive vulnerability monitoring for Juniper SRX routers
running Junos 20.2R3-S2.5, including security advisory tracking, configuration
compliance, and automated alerting.
"""

import os
import sys
import yaml
import json
import time
import logging
import schedule
import requests
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from pathlib import Path
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders

# Third-party imports
import paramiko
from netmiko import ConnectHandler
from bs4 import BeautifulSoup
import pandas as pd
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('juniper_monitor.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Rich console for better output
console = Console()

@dataclass
class Vulnerability:
    """Data class for vulnerability information"""
    cve_id: str
    title: str
    description: str
    severity: str
    affected_versions: List[str]
    published_date: str
    source: str
    juniper_advisory: Optional[str] = None
    remediation: Optional[str] = None

@dataclass
class RouterInfo:
    """Data class for router information"""
    name: str
    ip: str
    model: str
    junos_version: str
    location: str
    critical: bool
    last_scan: Optional[datetime] = None
    vulnerabilities: List[Vulnerability] = None

class JuniperVulnerabilityMonitor:
    """Main class for Juniper SRX vulnerability monitoring"""
    
    def __init__(self, config_file: str = "config.yaml"):
        """Initialize the vulnerability monitor"""
        self.config = self._load_config(config_file)
        self.routers = self._load_routers()
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Juniper-Security-Monitor/1.0 (ISP-NOC)'
        })
        
    def _load_config(self, config_file: str) -> Dict:
        """Load configuration from YAML file"""
        try:
            with open(config_file, 'r') as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            console.print(f"[red]Configuration file {config_file} not found![/red]")
            sys.exit(1)
        except yaml.YAMLError as e:
            console.print(f"[red]Error parsing configuration file: {e}[/red]")
            sys.exit(1)
    
    def _load_routers(self) -> List[RouterInfo]:
        """Load router information from configuration"""
        routers = []
        for router_config in self.config['routers']:
            router = RouterInfo(
                name=router_config['name'],
                ip=router_config['ip'],
                model=router_config['model'],
                junos_version=router_config['junos_version'],
                location=router_config['location'],
                critical=router_config['critical'],
                vulnerabilities=[]
            )
            routers.append(router)
        return routers
    
    def check_juniper_security_advisories(self) -> List[Vulnerability]:
        """Check Juniper security advisories for SRX routers"""
        console.print("[blue]Checking Juniper Security Advisories...[/blue]")
        
        vulnerabilities = []
        
        # Juniper Security Advisory URLs
        advisory_urls = [
            "https://supportportal.juniper.net/s/article/2023-12-Security-Bulletin-Junos-OS-SRX-Series-and-EX-Series-Multiple-vulnerabilities-in-J-Web-can-be-combined-to-achieve-Remote-Code-Execution-RCE",
            "https://supportportal.juniper.net/s/article/2023-11-Security-Bulletin-Junos-OS-SRX-Series-and-EX-Series-Multiple-vulnerabilities-in-J-Web-can-be-combined-to-achieve-Remote-Code-Execution-RCE",
            "https://supportportal.juniper.net/s/article/2023-10-Security-Bulletin-Junos-OS-SRX-Series-and-EX-Series-Multiple-vulnerabilities-in-J-Web-can-be-combined-to-achieve-Remote-Code-Execution-RCE"
        ]
        
        for url in advisory_urls:
            try:
                response = self.session.get(url, timeout=30)
                if response.status_code == 200:
                    soup = BeautifulSoup(response.content, 'html.parser')
                    
                    # Extract advisory information (this is a simplified version)
                    # In practice, you'd need to parse the specific HTML structure
                    title = soup.find('title')
                    if title:
                        vuln = Vulnerability(
                            cve_id="JUNIPER-ADVISORY",
                            title=title.text.strip(),
                            description="Juniper Security Advisory",
                            severity="high",
                            affected_versions=["20.2R3-S2.5"],
                            published_date=datetime.now().strftime("%Y-%m-%d"),
                            source="Juniper Security Advisory",
                            juniper_advisory=url
                        )
                        vulnerabilities.append(vuln)
                        
            except Exception as e:
                logger.error(f"Error checking Juniper advisory {url}: {e}")
        
        return vulnerabilities
    
    def check_cve_database(self) -> List[Vulnerability]:
        """Check CVE database for Juniper SRX vulnerabilities"""
        console.print("[blue]Checking CVE Database for Juniper SRX vulnerabilities...[/blue]")
        
        vulnerabilities = []
        
        # Search for Juniper SRX related CVEs
        search_terms = [
            "juniper srx",
            "junos 20.2",
            "juniper firewall",
            "juniper security"
        ]
        
        for term in search_terms:
            try:
                # Using NIST NVD API (free tier)
                url = f"https://services.nvd.nist.gov/rest/json/cves/2.0"
                params = {
                    'keywordSearch': term,
                    'resultsPerPage': 20
                }
                
                response = self.session.get(url, params=params, timeout=30)
                if response.status_code == 200:
                    data = response.json()
                    
                    for vuln_data in data.get('vulnerabilities', []):
                        cve = vuln_data.get('cve', {})
                        cve_id = cve.get('id', '')
                        
                        # Check if this CVE affects Junos 20.2R3-S2.5
                        if self._affects_junos_version(cve, "20.2R3-S2.5"):
                            vuln = Vulnerability(
                                cve_id=cve_id,
                                title=cve.get('descriptions', [{}])[0].get('value', ''),
                                description=cve.get('descriptions', [{}])[0].get('value', ''),
                                severity=self._get_cvss_severity(cve),
                                affected_versions=["20.2R3-S2.5"],
                                published_date=cve.get('published', ''),
                                source="NIST NVD"
                            )
                            vulnerabilities.append(vuln)
                            
            except Exception as e:
                logger.error(f"Error checking CVE database for term '{term}': {e}")
        
        return vulnerabilities
    
    def _affects_junos_version(self, cve_data: Dict, junos_version: str) -> bool:
        """Check if a CVE affects the specific Junos version"""
        # This is a simplified check - in practice, you'd need more sophisticated
        # version matching logic based on Juniper's versioning scheme
        descriptions = cve_data.get('descriptions', [])
        for desc in descriptions:
            if 'juniper' in desc.get('value', '').lower() and 'junos' in desc.get('value', '').lower():
                return True
        return False
    
    def _get_cvss_severity(self, cve_data: Dict) -> str:
        """Extract CVSS severity from CVE data"""
        try:
            metrics = cve_data.get('metrics', {})
            cvss_v3 = metrics.get('cvssMetricV31', [{}])[0] or metrics.get('cvssMetricV30', [{}])[0]
            if cvss_v3:
                base_severity = cvss_v3.get('cvssData', {}).get('baseSeverity', 'MEDIUM')
                return base_severity.lower()
        except:
            pass
        return "medium"
    
    def scan_router_configuration(self, router: RouterInfo) -> Dict:
        """Scan router configuration for security issues"""
        console.print(f"[blue]Scanning configuration for {router.name}...[/blue]")
        
        scan_results = {
            'router_name': router.name,
            'scan_time': datetime.now(),
            'security_issues': [],
            'configuration_checks': {}
        }
        
        try:
            # Connect to router using Netmiko
            device = {
                'device_type': 'juniper_junos',
                'host': router.ip,
                'username': self.config['routers'][0]['username'],  # Assuming same username
                'password': os.getenv('ROUTER_PASSWORD'),  # From environment variable
                'port': 22,
                'timeout': 30
            }
            
            with ConnectHandler(**device) as connection:
                # Check for common security issues
                security_checks = [
                    ('show system services', 'Check for unnecessary services'),
                    ('show system login', 'Check login configuration'),
                    ('show system syslog', 'Check logging configuration'),
                    ('show security policies', 'Check security policies'),
                    ('show system processes extensive', 'Check running processes')
                ]
                
                for command, description in security_checks:
                    try:
                        output = connection.send_command(command)
                        scan_results['configuration_checks'][description] = {
                            'command': command,
                            'output': output[:500] + '...' if len(output) > 500 else output
                        }
                    except Exception as e:
                        scan_results['security_issues'].append(f"Error running {command}: {e}")
                
                # Check for specific vulnerabilities
                if self._check_jweb_vulnerability(connection):
                    scan_results['security_issues'].append(
                        "J-Web interface may be vulnerable to RCE attacks"
                    )
                
        except Exception as e:
            scan_results['security_issues'].append(f"Connection failed: {e}")
            logger.error(f"Failed to scan {router.name}: {e}")
        
        return scan_results
    
    def _check_jweb_vulnerability(self, connection) -> bool:
        """Check for J-Web vulnerability indicators"""
        try:
            # Check if J-Web is enabled
            output = connection.send_command('show configuration system services web-management')
            if 'http' in output.lower() or 'https' in output.lower():
                return True
        except:
            pass
        return False
    
    def generate_security_report(self) -> str:
        """Generate comprehensive security report"""
        console.print("[green]Generating Security Report...[/green]")
        
        report = f"""
# Juniper SRX Security Report
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Executive Summary
- Total Routers Monitored: {len(self.routers)}
- Critical Routers: {sum(1 for r in self.routers if r.critical)}
- Total Vulnerabilities Found: {len(self.vulnerabilities)}
- High/Critical Vulnerabilities: {sum(1 for v in self.vulnerabilities if v.severity in ['high', 'critical'])}

## Router Status
"""
        
        for router in self.routers:
            report += f"""
### {router.name} ({router.ip})
- Model: {router.model}
- Junos Version: {router.junos_version}
- Location: {router.location}
- Critical: {'Yes' if router.critical else 'No'}
- Last Scan: {router.last_scan or 'Never'}
"""
        
        report += f"""
## Vulnerabilities Found
"""
        
        for vuln in self.vulnerabilities:
            report += f"""
### {vuln.cve_id} - {vuln.title}
- Severity: {vuln.severity.upper()}
- Source: {vuln.source}
- Published: {vuln.published_date}
- Description: {vuln.description[:200]}...
- Affected Versions: {', '.join(vuln.affected_versions)}
"""
        
        report += f"""
## Recommendations
1. Review all high/critical vulnerabilities immediately
2. Schedule maintenance windows for security updates
3. Implement additional security controls for J-Web interfaces
4. Consider upgrading to latest Junos version if possible
5. Review and update security policies

## Next Steps
- Schedule vulnerability remediation
- Update router configurations
- Implement monitoring alerts
- Regular security assessments
"""
        
        return report
    
    def send_alert(self, subject: str, message: str, severity: str = "medium"):
        """Send security alert via email"""
        if not self.config['alerts']['email']['enabled']:
            return
        
        try:
            msg = MIMEMultipart()
            msg['From'] = self.config['alerts']['email']['from_address']
            msg['To'] = ', '.join(self.config['alerts']['email']['to_addresses'])
            msg['Subject'] = f"[{severity.upper()}] {subject}"
            
            msg.attach(MIMEText(message, 'plain'))
            
            server = smtplib.SMTP(
                self.config['alerts']['email']['smtp_server'],
                self.config['alerts']['email']['smtp_port']
            )
            server.starttls()
            
            # Note: In production, use proper authentication
            # server.login(username, password)
            
            server.send_message(msg)
            server.quit()
            
            console.print(f"[green]Alert sent: {subject}[/green]")
            
        except Exception as e:
            logger.error(f"Failed to send alert: {e}")
    
    def run_full_scan(self):
        """Run complete vulnerability scan"""
        console.print(Panel.fit("[bold blue]Starting Juniper SRX Vulnerability Scan[/bold blue]"))
        
        # Check for new vulnerabilities
        juniper_vulns = self.check_juniper_security_advisories()
        cve_vulns = self.check_cve_database()
        
        self.vulnerabilities = juniper_vulns + cve_vulns
        
        # Scan each router
        for router in self.routers:
            router.last_scan = datetime.now()
            scan_results = self.scan_router_configuration(router)
            
            # Check for critical issues
            if scan_results['security_issues']:
                alert_msg = f"""
Critical security issues found on {router.name}:
{chr(10).join(scan_results['security_issues'])}
                """
                self.send_alert(
                    f"Security Issues on {router.name}",
                    alert_msg,
                    "critical"
                )
        
        # Generate and save report
        report = self.generate_security_report()
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f"security_report_{timestamp}.txt"
        
        with open(report_file, 'w') as f:
            f.write(report)
        
        console.print(f"[green]Report saved to: {report_file}[/green]")
        
        # Display summary
        self.display_summary()
    
    def display_summary(self):
        """Display scan summary in rich format"""
        table = Table(title="Juniper SRX Security Scan Summary")
        
        table.add_column("Router", style="cyan")
        table.add_column("Status", style="green")
        table.add_column("Issues", style="red")
        table.add_column("Last Scan", style="yellow")
        
        for router in self.routers:
            status = "✅ Online" if router.last_scan else "❌ Never Scanned"
            issues = len([v for v in self.vulnerabilities if router.junos_version in v.affected_versions])
            last_scan = router.last_scan.strftime("%Y-%m-%d %H:%M") if router.last_scan else "Never"
            
            table.add_row(router.name, status, str(issues), last_scan)
        
        console.print(table)
        
        # Vulnerability summary
        if self.vulnerabilities:
            vuln_table = Table(title="Vulnerabilities Found")
            vuln_table.add_column("CVE ID", style="cyan")
            vuln_table.add_column("Severity", style="red")
            vuln_table.add_column("Source", style="blue")
            
            for vuln in self.vulnerabilities:
                vuln_table.add_row(vuln.cve_id, vuln.severity.upper(), vuln.source)
            
            console.print(vuln_table)
    
    def start_monitoring(self):
        """Start continuous monitoring"""
        console.print("[green]Starting continuous monitoring...[/green]")
        
        # Schedule regular scans
        schedule.every(self.config['monitoring']['scan_interval_hours']).hours.do(self.run_full_scan)
        schedule.every(self.config['monitoring']['security_advisory_check_interval_hours']).hours.do(
            self.check_juniper_security_advisories
        )
        
        # Run initial scan
        self.run_full_scan()
        
        # Keep running
        while True:
            schedule.run_pending()
            time.sleep(60)

def main():
    """Main function"""
    console.print(Panel.fit("[bold green]Juniper SRX Vulnerability Monitor[/bold green]\n[italic]IT Security Specialist - ISP/NOC[/italic]"))
    
    monitor = JuniperVulnerabilityMonitor()
    
    if len(sys.argv) > 1:
        if sys.argv[1] == "scan":
            monitor.run_full_scan()
        elif sys.argv[1] == "monitor":
            monitor.start_monitoring()
        else:
            console.print("[red]Usage: python juniper_vulnerability_monitor.py [scan|monitor][/red]")
    else:
        monitor.run_full_scan()

if __name__ == "__main__":
    main()
